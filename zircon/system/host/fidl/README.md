<!-- # Fidl compiler -->
# FIDL编译器
----

[*英文原文快照*](https://github.com/fuchsia-mirror/zircon/blob/00faaac908ed4c5a59bfab95b6831b33df6a5cb0/system/host/fidl/README.md)

----
<!-- ## Pipeline -->
## 流水线

<!-- ### Loading a file -->
### 加载文件

<!-- All the fidl files in a library compilation are loaded by a
[SourceManager](lib/source_manager.h). This thing's job is to own the buffers backing
files. These buffers are kept alive for the entire pipeline. Tokens,
for example, are essentially a string view plus some metadata
describing their source location (a file and position). -->
库中所有FIDL文件的编译都由[SourceManager](https://github.com/fuchsia-mirror/zircon/blob/master/system/host/fidl/include/fidl/source_manager.h)加载。 
它的工作是为源代码文件提供缓冲区支持，这些缓冲区在整个编译流水线均保持活动状态。 
例如，令牌本质上是一个字符串加上一些描述其源位置（文件和文件中的位置）的元数据。

<!-- ### Parsing a file -->
### 解析文件

<!-- The Fidl compiler first parses each file into an in-memory AST, which
is defined by the structures in [ast.h](lib/ast.h). This parsing operation
starts by reading the file into memory, and then lexing the contents
into a [token](lib/token.h) stream. The [parser](lib/parser.cpp) proper then
parses the stream into the hierarchical AST. At this point names of
types are unresolved (they could end up pointing to types in another
file or library, or simply be garbage), and nested declarations are
still nested in the AST. -->

FIDL编译器首先将每个文件解析为内存中的AST，它由[ast.h](https://github.com/fuchsia-mirror/zircon/blob/master/system/host/fidl/include/fidl/ast.h)中的结构体所定义。 
此解析操作首先将文件读入内存，然后将其内容放入[令牌(token)](https://github.com/fuchsia-mirror/zircon/blob/master/system/host/fidl/include/fidl/token.h)流中，然后再由[解析器(parser)](https://github.com/fuchsia-mirror/zircon/blob/master/system/host/fidl/include/fidl/parser.cpp)将流解析为分层的AST。 
此时类型的名称尚未解析（它们可能最终指向另一个文件或库中的类型，或者只是毫无用处的值），并且嵌套声明仍然相互嵌套在AST中。

<!-- This step will fail if any of the given files is not valid Fidl. -->

此阶段如果有任何无效的FIDL文件，那么此步骤将导致失败。

<!-- ### Flattening a library -->
### 平展FIDL库
<!-- 
Once all the files are parsed into AST nodes, it's time to flatten the
representation. -->
将所有文件解析为AST节点后，即可在此阶段平展其表示。

<!-- Recall that some declarations can be nested. For instance, a const
declaration can be present in an interface or struct declaration. -->


<!-- Flattening pulls all the declarations out to one level, which entails
computing fully qualified names for nested types. -->
根据FIDL的语言规范，声明可以相互嵌套，例如，常量的声明可以出现在接口或结构体的声明中。
平展操作即是将所有声明设定在同一个级别，因此需要计算这些嵌套类型的完整全限定名称。

<!-- ### Resolving names in a library -->
### 解析FIDL库中的名称
<!-- 
Many parts of a fidl file refer to each other by name. For instance, a
struct may have a field whose type is given by the (possibly
qualified) name of some other struct. Any name that can't be resolved
(because it is not present in any of the given files or library
dependencies) causes compilation to fail at this stage. -->
FIDL文件的许多部分通过名称来进行相互引用。 
例如，结构体可以有一个字段，其类型由某个其他（加以限定的）结构体的名称给出。 
任何无法解析的（即不存在于任何给定的文件或库依赖项中的）名称会导致编译在此阶段失败。

<!-- ### Computing layout -->
### 库的布局的计算
<!-- 
At this stage layouts of all data structures are computed. This
includes both the coding tables for all of the messages defined by the
library, as well as the wire formats of those messages. The in-memory
representation of this layout is defined by the structures in
[coded_ast.h](lib/coded_ast.h). -->

所有数据结构的布局都将在此阶段被计算。 
这里所说的布局包括库定义的所有消息的编码表，以及这些消息的有线格式。
布局在内存中的表示由[coded_ast.h](https://github.com/fuchsia-mirror/zircon/blob/master/system/host/fidl/include/fidl/coded_ast.h)中的结构体所定义。

<!-- This step can fail in a few ways. If a given message statically
exceeds the limits of a channel message, compilation will
fail. Statically exceeding the recursion limit of Fidl decoding will
also cause compilation to fail. -->

数个方面的问题可能会导致该步骤失败。
如果给定的消息静态地超过通道的消息大小限制，则编译将失败。 
另外，静态地超过FIDL解码过程的递归限制也将导致编译失败。

<!-- ### Backend generation -->
### 后端生成

<!-- At this stage, nothing about the Fidl library per se should cause
compilation to fail (anything particular to a certain language binding
could fail, or the compiler could be given a bogus location to put its
output etc.). -->
到了这个阶段，关于FIDL库本身的任何内容都不会导致编译失败（但特定于某种语言绑定的任何特定内容都可能失败，包括编译器被指定输出结果到不合法的位置上等）。

<!-- #### C -->
#### C语言

<!-- C bindings are directly generated from the library layout. -->
C语言的后端绑定直接从库的布局中生成。

#### JSON

<!-- All other language bindings are generated by another program. -->
所有其他语言的绑定都由另一个外部程序所生成。