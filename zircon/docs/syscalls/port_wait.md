# zx_port_wait
---

[*英文原文快照*](https://github.com/fuchsia-mirror/zircon/blob/d17af78df889107ed5035b3f420567675a3c6ee5/docs/syscalls/port_wait.md)

---
<!-- ## NAME -->
## 名称

<!-- port_wait - wait for a packet arrival in a port -->
port_wait —— 等待数据包到达端口

<!-- ## SYNOPSIS -->
## 概要

```
#include <zircon/syscalls.h>
#include <zircon/syscalls/port.h>

zx_status_t zx_port_wait(zx_handle_t handle, zx_time_t deadline, zx_port_packet_t* packet);
```

<!-- ## DESCRIPTION -->
## 描述
<!-- 
**port_wait**() is a blocking syscall which causes the caller to wait until at least
one packet is available. -->
**port_wait()** 是一个阻塞系统调用，其功能是使调用者至少等到有一个来自端口的数据包可用。

<!-- Upon return, if successful *packet* will contain the earliest (in FIFO order)
available packet data. -->
调用返回时，如果成功，则*packet*将包含最早（以FIFO顺序）到达队列的数据包。

<!-- The *deadline* indicates when to stop waiting for a packet (with respect to
**ZX_CLOCK_MONOTONIC**).  If no packet has arrived by the deadline,
**ZX_ERR_TIMED_OUT** is returned.  The value **ZX_TIME_INFINITE** will
result in waiting forever.  A value in the past will result in an immediate
timeout, unless a packet is already available for reading. -->
*deadline*标示何时停止等待数据包（相对于**ZX_CLOCK_MONOTONIC**时间）。如果在截止时间到来时没有数据包到达，则返回**ZX_ERR_TIMED_OUT**。传递**ZX_TIME_INFINITE**到*deadline*将导致永远等待，除非数据包已经在队列中可用于读取，否则过去的值将导致立刻超时返回。

<!-- Unlike **zx_object_wait_one**() and **zx_object_wait_many**() only one
waiting thread is released (per available packet) which makes ports
amenable to be serviced by thread pools. -->
与**zx_object_wait_one()** 和**zx_object_wait_many()** 不同的是，该调用（对于每个可用数据包）只释放一个等待线程，这使得端口可以由线程池提供服务。

<!-- There are two sources of packets: manually queued packets with **port_queue**() and packets
generated by kernel when objects registered with **object_wait_async**() change state. In both
cases the packet is always of type **zx_port_packet_t**: -->
数据包的来源有两个：调用**port_queue()** 手动排队的数据包，和当使用**object_wait_async()** 注册的对象改变状态时，内核所生成的数据包。这两种情况下，数据包始终为**zx_port_packet_t**类型：

```
struct zx_port_packet_t {
    uint64_t key;
    uint32_t type;
    int32_t status;
    union {
        zx_packet_user_t user;
        zx_packet_signal_t signal;
        zx_packet_exception_t exception;
    };
};
```

<!-- In the case of packets generated via **port_queue**() *key* is the key in the
input packet, *type* is set to **ZX_PKT_TYPE_USER** and the union is of type **zx_packet_user_t**. -->
如果是通过**port_queue()** 生成的数据包，*key*是数据包中的键值，*type*被设置为**ZX_PKT_TYPE_USER**类型，并且联合字段的类型为**zx_packet_user_t**。

```
typedef union zx_packet_user {
    uint64_t u64[4];
    uint32_t u32[8];
    uint16_t u16[16];
    uint8_t   c8[32];
} zx_packet_user_t;
```

<!-- The caller of **port_queue**() controls all the values in the structure. -->
**port_queue()** 的调用者控制上述结构体中的所有值。

<!-- In the case of packets generated via **object_wait_async**() *key* is the key passed to the
syscall, *type* is set to either **ZX_PKT_TYPE_SIGNAL_ONE** or **ZX_PKT_TYPE_SIGNAL_REP**
and the union is of type **zx_packet_signal_t**: -->
如果是通过**object_wait_async()** 生成的数据包，*key*是传递给系统调用的键值，*type*被设置为**ZX_PKT_TYPE_SIGNAL_ONE**或**ZX_PKT_TYPE_SIGNAL_REP**类型，并且联合字段的类型为**zx_packet_signal_t**：

```
typedef struct zx_packet_signal {
    zx_signals_t trigger;
    zx_signals_t observed;
    uint64_t count;
} zx_packet_signal_t;
```

<!-- for **ZX_WAIT_ASYNC_ONCE** and **ZX_WAIT_ASYNC_REPEATING**: *trigger* is the signals
used in the call to **object_wait_async**() and *count* is a per object defined count
of pending operations. Use *key* to track what object this packet corresponds to and
therefore match *count* with the operation. -->
对于**ZX_WAIT_ASYNC_ONCE**和**ZX_WAIT_ASYNC_REPEATING**类型而言：*trigger*是调用**object_wait_async()** 时使用的信号，*count*是每个对象定义的待处理操作数。使用*key*来跟踪此数据包对应的对象，从而使*count*与操作相匹配。

<!-- See [object_wait_async](object_wait_async.md) for more details. -->
有关更多详细的信息，请参见[object_wait_async](object_wait_async.md)。

<!-- ## RIGHTS -->
## 权限

TODO(ZX-2399)

<!-- ## RETURN VALUE -->
## 返回值

<!-- **port_wait**() returns **ZX_OK** on successful packet dequeuing. -->
**port_wait()** 等待数据包成功出队列，并返回**ZX_OK**。

<!-- ## ERRORS -->
## 错误码

<!-- **ZX_ERR_BAD_HANDLE** *handle* is not a valid handle. -->
**ZX_ERR_BAD_HANDLE**：*handle*是无效句柄。

<!-- **ZX_ERR_INVALID_ARGS** *packet* isn't a valid pointer -->
**ZX_ERR_INVALID_ARGS**：*packet*不是有效指针。

<!-- **ZX_ERR_ACCESS_DENIED** *handle* does not have **ZX_RIGHT_WRITE** and may
not be waited upon. -->
**ZX_ERR_ACCESS_DENIED**：*handle*没有**ZX_RIGHT_WRITE**权限，因此可能无法等待到数据包。
<!-- 
**ZX_ERR_TIMED_OUT** *deadline* passed and no packet was available. -->
**ZX_ERR_TIMED_OUT**：*deadline*已过，且没有获取到数据包。

<!-- ## SEE ALSO -->
## 另见

<!-- [port_create](port_create.md).
[port_queue](port_queue.md).
[object_wait_async](object_wait_async.md). -->

[port_create](port_create.md)，[port_queue](port_queue.md)，[object_wait_async](object_wait_async.md)。