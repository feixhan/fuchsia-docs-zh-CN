<!-- # Mozart Input system -->
# Mozart输入子系统
---

[*英文原文快照*](https://github.com/fuchsia-mirror/garnet/blob/ae95d58984f6fc99df2f79dbe79c6c5406c0cf04/docs/ui_input.md)

---
<!-- This document describes how the input system works inside Mozart. -->
本文档描述了输入系统在Mozart内部工作的细节。

<!-- ## Devices -->
## 设备

<!-- Zircon provides access to devices through the file system under
`/dev/class/input`. Those are HID devices and there are associated ioctls to
retrieve the description report and simple reads on those devices will return
the event reports. -->
Zircon通过`/dev/class/input`下的文件系统提供对设备的访问功能。该目录下都是HID设备，并且有相关的ioctl操作来获取这些设备的描述报告信息，通过向文件系统的简单读取可以返回事件报告。

<!-- ## HID Reports to `InputEvent`. -->
## HID向`InputEvent`报告。
<!-- 
When launching an application through the sysmgr process,
`src/root_presenter` is launched as a singleton to create the root of the
`Presentation`. When starting, root_presenter starts `src/input_reader` which
will monitor the `/dev/class/input` directory for new devices and discover
existing devices if they are already present. -->

当通过sysmgr进程启动应用程序时，`src/root_presenter`作为单例启动，以创建`Presentation`的根。在启动的过程中，root_presenter启动`src/input_reader`，它将监视新设备的`/dev/class/input`目录并发现已存在的现有设备。

<!-- Any time a device is detected (or discovered the first time) `InputReader` reads
the HID description report and converts it into a DeviceDescriptor. -->

无论何时检测到设备（或第一次被发现），`InputReader`都会读取HID描述报告并将其转换为DeviceDescriptor。

<!-- That device is then registered through the `InputDeviceRegistry` which is
implemented by the root presenter `App` class. `App` then notifies any existing
`Presentation` of the new device. It also creates a channel for that device in
the form of an `InputDevice` which `InputReader` can keep a reference to, to
forward events. `Presentation` creates a `DeviceState` (found under `lib/input`)
which will be used later in the process. -->

该设备而后通过`InputDeviceRegistry`注册表来进行注册，该注册表由root presenter的`App`类实现，而后`App`通知新设备的任何现有`Presentation`。它还以`InputDevice`的形式为该设备创建一个通道，`InputReader`可以保持对它的引用来转发事件。`Presentation`创建一个`DeviceState`（可在`lib/input`目录下找到），并稍后在进程中被使用。

<!-- During the initialization of the device, `InputReader` will add the handle
corresponding to that device to the list of handles to monitor for activity in
its message loop. Whenever activity is detected, it reads the packet and the
`InputInterpreter` associated to this device, will convert the report into an
`InputReport`. -->

在设备初始化期间，`InputReader`会将该设备对应的句柄添加到句柄列表中，以监视其消息循环中的活动。每当检测到活动时，它会读取数据包，并且与此设备关联的`InputInterpreter`会将报告转换为`InputReport`。

<!-- The `InputReport` is forwarded through the `InputDevice` channel created during
the registration process to the root presenter `App` which dispatches it to the
different `Presentations`. -->

`InputReport`通过在注册过程中创建的`InputDevice`通道转发到root presenter`App`，后者将`InputReport`发送到不同的`Presentations`中。

<!-- The `DeviceState` held by a `Presentation` will convert the `InputReport` into
an `InputEvent`. -->

进一步地，`Presentation`持有的`DeviceState`将`InputReport`转换为`InputEvent`。

<!-- ## The life of an `InputEvent`. -->

## `InputEvent`的生命周期

<!-- Once an `InputEvent` has been generated by a `DeviceState`, it's forwarded to
`src/input_manager`, a `ViewAssociate` dedicated to process input events which
implements the `InputDispatcher` service. -->

一旦`InputEvent`通过`DeviceState`生成，它就会被转发到`src/input_manager`下。有`ViewAssociate`对象专门用于处理实现`InputDispatcher`服务的输入事件。

<!-- There is one `InputDispatcherImpl` per view tree. The view tree is owned by
`Presentation`. So the `InputEvent` is forwarded to each one of them. -->

每个视图树具有一个`InputDispatcherImpl`。该视图树由`Presentation`拥有，因此`InputEvent`被转发到它们中的每一个。

<!-- An `InputDispatcherImpl` will query the `ViewInspector` service to retrieve the
input focus chain. It will then dispatch those events through the chain. It
starts at the deepest view in that chain and propagates the event until the
`View` says it has handled the event though the
`InputConnection::InputListener::OnEvent` method. -->

`InputDispatcherImpl`查询`ViewInspector`服务以检索输入焦点链，然后它将通过焦点链发送这些事件。从该链中最深的视图开始并传播事件，直到`View`表示它已通过`InputConnection::InputListener::OnEvent`方法处理完事件。

<!-- ## Input Focus. -->
## 输入焦点

<!-- When the `InputEvent` is a touch or mouse down event, `InputDispatcherImpl`,
using the `ViewInspector`, runs the `HitTest` on the scene graph. The result
contains a tree of nodes that were hit. -->

当`InputEvent`是触摸或鼠标按下事件时，使用`ViewInspector`的`InputDispatcherImpl`在场景图上运行`HitTest`，其结果包含一个被命中的节点树。

<!-- 
`InputDispatcherImpl` uses `ViewInspector` to convert this list of nodes into
`Views`, at which point it requests in parallel the different views whether they
are hit or not and which of their children should be considered for the hit.
This is done through the `InputConnection::ViewHitTester` interface. -->

`InputDispatcherImpl`使用`ViewInspector`将节点列表转换为`Views`，此时它并行请求，不同的视图是否被击中，以及考虑哪个子节点被击中，该过程通过`InputConnection::ViewHitTester`接口实现完成的。

<!-- Once all views have responded, `InputDispatcherImpl` reconciles the results
walking down the tree from the top and using the answer to which subviews should
participate to build a tree of interested parties. For each leaf it will then
create focus chain, which is the branch that leads from that leaf to the root. -->

一旦所有视图都得到响应，`InputDispatcherImpl`会协调自顶向下遍历节点树上的结果，并使用子视图应该参与的答案来构建感兴趣方面的树。然后，对于每个叶子节点，它将创建焦点链，该焦点链是从该叶子到根的一个分支。

<!-- For now `InputDispatcherImpl` picks one of the chain but this will be changed in
the future. It then tells the `ViewInspector` which chain is now in focus. -->

当前的实现中，`InputDispatcherImpl`选择其中一个链（，但将来可能会改变），而后它告诉`ViewInspector`哪个链现在是处于聚焦状态。
